package org.jooq.mcve.test.java.postgres;

import org.jooq.DSLContext;
import org.jooq.Record3;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import static org.jooq.mcve.java.postgres.Tables.PHOTOS;
import static org.jooq.mcve.java.postgres.Tables.PRODUCTS;
import org.jooq.mcve.java.postgres.tables.records.TestRecord;
import org.jooq.tools.JooqLogger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.utility.ResourceReaper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

import static org.jooq.mcve.java.postgres.Tables.TEST;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class JavaTest {

    static JooqLogger             log = JooqLogger.getLogger(JavaTest.class);
    static PostgreSQLContainer<?> db;
    static Connection             connection;
    static DSLContext             ctx;

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("jooq.codegen.jdbc.url") == null) {
            db = new org.testcontainers.containers.PostgreSQLContainer<>("postgres:latest")
                 .withUsername("postgres")
                 .withDatabaseName("postgres")
                 .withPassword("postgres")
                 .withInitScript("db/migration/init.sql");

            db.start();
            System.setProperty("jooq.codegen.jdbc.url", db.getJdbcUrl());
            System.setProperty("jooq.codegen.jdbc.username", db.getUsername());
            System.setProperty("jooq.codegen.jdbc.password", db.getPassword());
        }

        Properties properties = new Properties();
        properties.setProperty("username", "postgres");
        properties.setProperty("password", "postgres");

        log.info("Connecting");
        connection = DriverManager.getConnection(
            System.getProperty("jooq.codegen.jdbc.url"),
            System.getProperty("jooq.codegen.jdbc.username"),
            System.getProperty("jooq.codegen.jdbc.password")
        );

        ctx = DSL.using(connection, SQLDialect.POSTGRES);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(TEST).execute();
    }

    @After
    public void after() throws Exception {
    }

    /**
     * This test work fines (no multiset)
     */
    @Test
    public void orderByTypeTest() {
        var ids = ctx.select(PHOTOS.ID)
            .from(PHOTOS)
            .where(PHOTOS.PRODUCT_ID.eq("P001"))
            .orderBy(
                DSL
                    .when(PHOTOS.BROADCAST_TYPE.eq(BroadcastType.PUBLIC.name()), DSL.value(0))
                    .when(PHOTOS.BROADCAST_TYPE.eq(BroadcastType.INTERNAL.name()), DSL.value(1))
                    .else_(2)
                    .asc(),
                PHOTOS.BROADCAST_ORDER.asc()
            )
            .fetch()
            .getValues(0);
        assertEquals("0c47aca2-ed5c-45e8-9fb4-a1ff5bf4307c", ids.get(0));
        assertEquals("4a902e72-5350-4541-89e8-0f54a4597ab6", ids.get(1));
        assertEquals("6e9cf78b-f4d2-48d9-8079-f4cb5fa5a8f9", ids.get(2));
        assertEquals("5ffadb01-df8b-47c1-ba70-bafb2cca3409", ids.get(3));
    }

    /**
     * This test works with 3.19.10 but fails with 3.19.11+
     */
    @Test
    public void orderByTypeMultisetTest() {
        var results = ctx
            .select(
                PRODUCTS.ID,
                DSL.multiset(
                    DSL.select(PHOTOS.ID, PHOTOS.BROADCAST_TYPE, PHOTOS.BROADCAST_ORDER)
                        .from(PHOTOS)
                        .where(PHOTOS.PRODUCT_ID.eq(PRODUCTS.ID))
                        .orderBy(
                            DSL
                                .when(PHOTOS.BROADCAST_TYPE.eq(BroadcastType.PUBLIC.name()), DSL.value(0))
                                .when(PHOTOS.BROADCAST_TYPE.eq(BroadcastType.INTERNAL.name()), DSL.value(1))
                                .else_(2)
                                .asc(),
                            PHOTOS.BROADCAST_ORDER.asc()
                        )
                ).as("photos")
            )
            .from(PRODUCTS)
            .where(PRODUCTS.ID.eq("P001"))
            .fetch();
        assertEquals("P001", results.getValue(0, 0));
        assertEquals(
            """
            +------------------------------------+--------------+---------------+
            |id                                  |broadcast_type|broadcast_order|
            +------------------------------------+--------------+---------------+
            |0c47aca2-ed5c-45e8-9fb4-a1ff5bf4307c|PUBLIC        |              0|
            |4a902e72-5350-4541-89e8-0f54a4597ab6|INTERNAL      |              6|
            |6e9cf78b-f4d2-48d9-8079-f4cb5fa5a8f9|INTERNAL      |             10|
            |5ffadb01-df8b-47c1-ba70-bafb2cca3409|NONE          |              1|
            +------------------------------------+--------------+---------------+
            """,
            results.getValue(0, 1).toString()
        );
    }

    enum BroadcastType {
        PUBLIC,
        INTERNAL,
        NONE
    }
}
